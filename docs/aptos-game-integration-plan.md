# Aptos Game Integration Plan

This document tracks how the 30-second trading rounds hook into the Aptos contract after wiring start/end transactions for every round. It also outlines the remaining gaps to close the loop on history, bankroll sizing, and production readiness.

## Updated Round Lifecycle
- **Round start** – `useP5Chart.startRound()` now emits `phase: 'start'` metadata. The Aptos chart (`src/components/AptosCandlestickChart.tsx`) calls `useAptosGameContract.startGame(betAmount, seed)` with the same seed driving the local candles.
- **Round play** – Positions accumulate P&L in `accumulatedPnL` while `gameState === 'playing'`. The hook prevents new on-chain rounds from starting until settlements finish, queueing any extra seeds it receives.
- **Round end** – `useP5Chart.endRound()` sends `phase: 'end'`. The chart calls `completeGame(gameSeed, isProfit, |PnL|)` immediately (even for zero P&L) to close out the on-chain round and unlock the next start.
- **Balance refresh** – After both start and completion transactions we schedule `fetchWalletBalance()` so the wallet widget reflects the treasury transfer and settlement.

## Contract State Tracking
- `start_game` now accepts the seed generated by the client and persists `{player, bet_amount, seed}` inside an `ActiveGames` resource keyed by the module address.
- `complete_game` pulls the entry for the signer, verifies the supplied seed matches, and removes it before paying out profits/losses.
- Helper functions `find_game_index`, `clone_seed`, and `seeds_match` iterate without mutable locals, keeping the module compatible with the Move compiler.
- `initialize_treasury` was extended so upgrades can re-create `EventHandles` or `ActiveGames` if they are missing.

## Client ↔ Contract Flow (current)
1. **Wallet connection** – When a wallet connects we mark `gameState = 'ready'`, fetch the balance, and wait for the first seed from `useP5Chart`.
2. **Round start** – On `phase: 'start'` we determine a wager (default 1 APT, capped by wallet balance) and send `start_game`. Any seeds arriving while the previous round is settling are queued and started once the state returns to `ready`.
3. **Round completion** – On `phase: 'end'` we call `complete_game` with the stored seed and accumulated P&L. The hook always finalises the round so the contract never keeps stale entries.
4. **Balance + telemetry** – Wallet balances reload after each transaction. Debug metadata now also includes the live `gameState` so we can reason about blocked settlements in dev tools.

## What Still Needs Attention
1. **Indexer / event history** – `getPlayerGameStartEvents` and `getPlayerGameEndEvents` remain stubs. We need either an indexer feed or RPC queries so history panels can confirm settlements.
2. **Bankroll rules** – The UI still hardcodes a 1 APT wager. We should design bankroll sizing (min/max vs. wallet balance) and expose controls for players.
3. **Error recovery** – If `complete_game` fails (e.g., user rejects the transaction) we currently reset to `ready`, leaving the on-chain round active. We’ll need a retry UX and possibly a “resume settlement” flow.
4. **Automated verification** – When the indexer arrives we should add integration tests that start/complete a round via the hook and assert the indexed events plus wallet delta.

## Verification Snapshot (Jan 2025)
- **Frontend** – `npm run build` (Vite production build) ✅
- **Move module** – `aptos move compile --skip-fetch-latest-git-deps` ✅
- **ESLint** – Fails today due to pre-existing issues in `rug_simulation.js` and generated `server/dist/index.js` (unchanged in this work).

These changes give us deterministic start/end settlement per round with matching seeds and per-player state on-chain. The next focus areas: wiring event history, fleshing out bankroll controls, and smoothing over settlement retries.
