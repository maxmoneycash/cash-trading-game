import { Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";

// Contract address on devnet (configurable via Vite env)
const DEFAULT_CONTRACT_ADDRESS = "0x37691b1a87e7d1054007c5687424ef10438993722925b189c09f1bc7fe172ac5";
const CONTRACT_ADDRESS = (import.meta.env.VITE_APTOS_CONTRACT_ADDRESS ?? DEFAULT_CONTRACT_ADDRESS) as string;

// Debug: Log which contract address is being used
console.log('ðŸ”§ GameContract using address:', CONTRACT_ADDRESS);

export interface CandleConfig {
  initial_price_fp: number;
  total_candles: number;
  interval_ms: number;
  fairness_version: number;
}

export interface GameStartEvent {
  player: string;
  bet_amount: number;
  seed: string;
  timestamp: number;
}

export interface GameEndEvent {
  player: string;
  bet_amount: number;
  profit: number;      // 0 if loss
  loss: number;        // 0 if profit
  payout: number;
  timestamp: number;
}

export class GameContract {
  private aptos: Aptos;
  private moduleAddress: string;

  constructor(network: Network = Network.DEVNET) {
    const config = new AptosConfig({ network });
    this.aptos = new Aptos(config);
    this.moduleAddress = CONTRACT_ADDRESS;
  }

  /**
   * Start a new trading game
   * @param signAndSubmitTransaction - Wallet function to sign transactions
   * @param betAmountAPT - Bet amount in APT (will be converted to octas)
   * @param seed - Deterministic game seed (hex string) generated by the client
   * @returns Transaction hash
   */
  async startGame(
    signAndSubmitTransaction: any,
    betAmountAPT: number,
    seed?: string
  ): Promise<string> {
    const betAmountOctas = Math.floor(betAmountAPT * 100000000); // Convert APT to octas

    const functionArguments: string[] = [betAmountOctas.toString()];
    const supportsSeedArgument = import.meta.env.VITE_APTOS_START_ACCEPTS_SEED === 'true';
    console.log('[GameContract] Seed support:', { supportsSeedArgument, seed, envValue: import.meta.env.VITE_APTOS_START_ACCEPTS_SEED });
    if (supportsSeedArgument && seed) {
      const seedHex = seed.startsWith('0x') ? seed : `0x${seed}`;
      functionArguments.push(seedHex);
    }

    const transaction = {
      data: {
        function: `${this.moduleAddress}::game::start_game`,
        functionArguments,
      },
      options: {
        maxGasAmount: 20000,
        gasUnitPrice: 100,
      }
    };

    console.log('[GameContract] Submitting start_game transaction:', transaction);
    const response = await signAndSubmitTransaction(transaction);
    console.log('[GameContract] Transaction submitted, response:', response);

    if (!response || !response.hash) {
      throw new Error('Transaction failed - no hash received');
    }

    console.log('[GameContract] Waiting for transaction confirmation...');
    await this.aptos.waitForTransaction({ transactionHash: response.hash });
    console.log('[GameContract] Transaction confirmed:', response.hash);
    return response.hash;
  }

  /**
   * Complete a trading game
   * @param signAndSubmitTransaction - Wallet function to sign transactions
   * @param seed - Game seed (hex string without 0x prefix)
   * @param isProfit - True if player made profit, false if loss
   * @param amountAPT - Profit or loss amount in APT
   * @returns Transaction hash
   */
  async completeGame(
    signAndSubmitTransaction: any,
    seed: string,
    isProfit: boolean,
    amountAPT: number
  ): Promise<string> {
    const amountOctas = Math.floor(amountAPT * 100000000); // Convert APT to octas

    // Ensure seed is in proper hex format
    const seedHex = seed.startsWith('0x') ? seed : `0x${seed}`;

    const transaction = {
      data: {
        function: `${this.moduleAddress}::game::complete_game`,
        functionArguments: [seedHex, isProfit, amountOctas.toString()],
      },
      options: {
        maxGasAmount: 20000,
        gasUnitPrice: 100,
      }
    };

    const response = await signAndSubmitTransaction(transaction);
    await this.aptos.waitForTransaction({ transactionHash: response.hash });
    return response.hash;
  }

  // Settle game with detailed trade history
  async settleGameWithTrades(
    signAndSubmitTransaction: any,
    betAmountAPT: number,
    seed: string,
    trades: Array<{
      entryPrice: number;
      exitPrice: number;
      entryCandleIndex: number;
      exitCandleIndex: number;
      size: number; // in APT
      pnl: number;  // in APT
    }>
  ): Promise<string> {
    // Ensure seed has 0x prefix
    const seedHex = seed.startsWith('0x') ? seed : `0x${seed}`;

    // Convert bet amount to octas
    const betAmountOctas = Math.floor(betAmountAPT * 100000000);

    // Calculate net P&L from all trades
    const netPnLAPT = trades.reduce((sum, trade) => sum + trade.pnl, 0);
    const isNetProfit = netPnLAPT > 0;
    const netPnLOctas = Math.floor(Math.abs(netPnLAPT) * 100000000);

    // Prepare trade arrays for the contract
    const entryPrices = trades.map(t => Math.floor(t.entryPrice * 100000000).toString());
    const exitPrices = trades.map(t => Math.floor(t.exitPrice * 100000000).toString());
    const entryCandleIndices = trades.map(t => t.entryCandleIndex.toString());
    const exitCandleIndices = trades.map(t => t.exitCandleIndex.toString());
    const sizes = trades.map(t => Math.floor(t.size * 100000000).toString());
    const pnls = trades.map(t => Math.floor(Math.abs(t.pnl) * 100000000).toString());

    const transaction = {
      data: {
        function: `${this.moduleAddress}::game::settle_game_with_trades`,
        functionArguments: [
          betAmountOctas.toString(),
          seedHex,
          entryPrices,
          exitPrices,
          entryCandleIndices,
          exitCandleIndices,
          sizes,
          pnls,
          isNetProfit,
          netPnLOctas.toString()
        ],
      },
      options: {
        maxGasAmount: 50000,  // Higher gas limit for complex transaction
        gasUnitPrice: 100,
      }
    };

    console.log('Submitting settle_game_with_trades transaction:', {
      betAmount: betAmountAPT,
      tradeCount: trades.length,
      netPnL: netPnLAPT,
      isNetProfit
    });

    const response = await signAndSubmitTransaction(transaction);

    if (!response || !response.hash) {
      throw new Error('Transaction failed - no hash received');
    }

    await this.aptos.waitForTransaction({ transactionHash: response.hash });
    return response.hash;
  }

  // New function for single payout transaction
  async processGamePayout(
    signAndSubmitTransaction: any,
    betAmountAPT: number,
    seed: string,
    isProfit: boolean,
    pnlAmountAPT: number  // absolute value of profit/loss
  ): Promise<string> {
    // Ensure seed has 0x prefix
    const seedHex = seed.startsWith('0x') ? seed : `0x${seed}`;

    const betAmountOctas = Math.floor(betAmountAPT * 100000000);
    const pnlAmountOctas = Math.floor(Math.abs(pnlAmountAPT) * 100000000);

    const transaction = {
      data: {
        function: `${this.moduleAddress}::game::process_game_payout`,
        functionArguments: [
          betAmountOctas.toString(),
          seedHex,
          isProfit,
          pnlAmountOctas.toString()
        ],
      },
      options: {
        maxGasAmount: 30000,  // Higher gas limit for the combined transaction
        gasUnitPrice: 100,
      }
    };

    console.log('Submitting process_game_payout transaction:', transaction);

    const response = await signAndSubmitTransaction(transaction);

    if (!response || !response.hash) {
      throw new Error('Transaction failed - no hash received');
    }

    await this.aptos.waitForTransaction({ transactionHash: response.hash });
    return response.hash;
  }

  /**
   * Get game start events for a player
   * @param playerAddress - Player's wallet address
   * @returns Array of game start events
   */
  async getPlayerGameStartEvents(playerAddress: string): Promise<GameStartEvent[]> {
    try {
      // For now, return empty array - events querying will be implemented later
      // The events are still being emitted and stored on-chain for verification
      console.log(`Getting game start events for ${playerAddress}`);
      return [];
    } catch (error) {
      console.error('Failed to get game start events:', error);
      return [];
    }
  }

  /**
   * Get game end events for a player
   * @param playerAddress - Player's wallet address
   * @returns Array of game end events
   */
  async getPlayerGameEndEvents(playerAddress: string): Promise<GameEndEvent[]> {
    try {
      // For now, return empty array - events querying will be implemented later
      // The events are still being emitted and stored on-chain for verification
      console.log(`Getting game end events for ${playerAddress}`);
      return [];
    } catch (error) {
      console.error('Failed to get game end events:', error);
      return [];
    }
  }

  /**
   * Get default candle configuration
   * Note: This would be a view function call, but for now we return the default
   */
  getDefaultCandleConfig(): CandleConfig {
    return {
      initial_price_fp: 10000000000, // $100.00 in fixed-point
      total_candles: 462, // Exactly 30s at 65ms interval - aligned with seededCandles.ts
      interval_ms: 65,
      fairness_version: 2,
    };
  }

  /**
   * Utility: Convert APT to octas
   */
  static aptToOctas(aptAmount: number): number {
    return Math.floor(aptAmount * 100000000);
  }

  /**
   * Utility: Convert octas to APT
   */
  static octasToApt(octas: number): number {
    return octas / 100000000;
  }

  /**
   * Get the contract address
   */
  getContractAddress(): string {
    return this.moduleAddress;
  }

  /**
   * Estimate transaction gas costs
   */
  estimateGasCosts(): { startGame: number; completeGame: number } {
    // Based on our testing: start_game uses ~17 gas, complete_game uses ~6 gas
    return {
      startGame: 0.000017, // APT
      completeGame: 0.000006, // APT
    };
  }
}

// Export the contract instance for easy use
export const gameContract = new GameContract();
